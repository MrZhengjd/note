MappedByteBuffer主要应用场景如下：
1.基于文件共享的高性能进程间通信（iPC）
2.大文件高性能访问读写

一个进程负责写入数据到内存映射文件中，其他进程从此映射文件中读取数据

MappedByteBuffer具备zerocopy的特性，transfer能节省异常缓冲区的复制过程，直接写入另一个channel上

UDP Socket只有一个接受缓存区，没有发送缓冲区 而tcp socket具备接受缓冲区和发送缓冲区，上层数据发送
只是数据从内核缓冲区复制到sockt的缓冲区，然后就返回一个send代表已发送，但是数据从socket发送一般都是socket的缓冲区
满了才会发数据的。

对tcp用户来讲，tcp缓冲区接受数据，如果应用进程一直都没有读取，则Buffer满了之后，发生的动作就是，通知tcp协议端口关闭，保证tcp
套接口接受缓冲区不会溢出，这就是滑动窗口的实现。而udp用户是不会缓冲数据直接丢弃数据的，所以他就不可靠

对于阻塞io来说：在读取socket数据的过程中，如果接受缓冲区为空，调用Socket的read方法会阻塞，直到有数据进入缓冲区；对于写数据到Socket
缓冲区，如果待发送数据大于缓冲区数据长度，则会阻塞在write方法上

非阻塞模式就是io线程与socket解耦的问题，引入事件机制来达到解耦，io底层存在一个i/0调度线程，不断扫描每个sockte的缓冲区，当发现写入缓冲区
为空的时候，就会产生一个Socket刻写事件，此时程序就可以吧数据写入socket里面，如果一次写不完，就等下次。读的情况也类似